---
title: "Benchmarking"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
```

## Multiplications are computationally costly

Avoid them as much as possible by using intermediate variables. Example:

```{r}
library(deSolve)

# 3 multiplications:
sir_equations1 <- function(time, variables, parameters) {
  with(as.list(c(variables, parameters)), {
    incidence <- beta * I * S
    recovery  <- gamma * I
    dS <- -incidence
    dI <-  incidence - recovery
    dR <-  recovery
    list(c(dS, dI, dR))
  })
}

# 6 multiplications:
sir_equations2 <- function(time, variables, parameters) {
  with(as.list(c(variables, parameters)), {
    dS <- -beta * I * S
    dI <-  beta * I * S - gamma * I
    dR <-  gamma * I
    list(c(dS, dI, dR))
  })
}

initial_values <- c(S = 999, I = 1, R = 0)
time_values <- seq(0, 30, .1)
parameters_values <- c(beta = .004, gamma = .5)

bench::mark(
  three_multiplications = 
    ode(y = initial_values, times = time_values, func = sir_equations1, parms = parameters_values),
  six_multiplications = 
    ode(y = initial_values, times = time_values, func = sir_equations2, parms = parameters_values)
)
```

## `return()`

Function calls are computationally expensive. Do not use any that is not
necessary, for example `return()` at the end of a function:

```{r}
library(deSolve)

# without return():
sir_equations1 <- function(time, variables, parameters) {
  with(as.list(c(variables, parameters)), {
    incidence <- beta * I * S
    recovery  <- gamma * I
    dS <- -incidence
    dI <-  incidence - recovery
    dR <-  recovery
    list(c(dS, dI, dR))
  })
}

# with return():
sir_equations2 <- function(time, variables, parameters) {
  with(as.list(c(variables, parameters)), {
    incidence <- beta * I * S
    recovery  <- gamma * I
    dS <- -incidence
    dI <-  incidence - recovery
    dR <-  recovery
    return(list(c(dS, dI, dR)))
  })
}

initial_values <- c(S = 999, I = 1, R = 0)
time_values <- seq(0, 30, .1)
parameters_values <- c(beta = .004, gamma = .5)

bench::mark(
  without_return = 
    ode(y = initial_values, times = time_values, func = sir_equations1, parms = parameters_values),
  with_return = 
    ode(y = initial_values, times = time_values, func = sir_equations2, parms = parameters_values)
)
```

## Rewriting built-in functions

Built-in functions comes with a number of internal checks that are useful for
interactive use. But if you know what you're doing, you are better off rewriting
some of these funtions from scractch, without the internal checks:

```{r}
x <- runif(1000)
bench::mark(
  from_scratch = sum(x) / length(x),
  built_in = mean(x)
)
```

## Sequence generation

If you're generating a sequence with a step of 1, there are multiple ways to do so:

```{r}
bench::mark(
  seq.int(0, 1000000),
  seq(0, 1000000),
  0:1000000
)
```

